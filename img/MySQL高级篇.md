# 第一章 MySQL逻辑架构

## 1.1 逻辑架构剖析

MySQL是经典的`C/S架构`，即`Client/Server架构`，服务器端程序使用`mysqld`。

不论客户端进程和服务器进程采用哪种方式进行通信，最后实现的效果都是：`客户端进程向服务器进程发送了一个SQL语句，服务器进程处理后再向客户端进程发送处理结果`。

那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为例展示：

<img src="MySQL高级篇.assets/image-20220920015036930.png" alt="image-20220920015036930" style="zoom:67%;" />

**MySQL架构图**：

<img src="MySQL高级篇.assets/image-20220920015607730.png" alt="image-20220920015607730" style="zoom: 80%;" />

MySQL从上到下分为

1. **Connectors层**：此层位于客户端，作用是通过各种数据库驱动与数据库建立TCP连接。

2. **连接层**：此层用于进行登录验证，通过TCP连接池用和多个客户端建立连接，利用MySQL线程池用于处理多个客户端请求。

3. **服务层**：此层的主要作用是处理SQL语句。总共有四个模块：

   - **SQL Interface**：SQL接口，用于接收客户端的SQL命令，并返回查询结果。

   - Parser：解析器，利用编译原理相关理论对SQL语句进行语法分析、词法分析和语义分析，如果发生语法错误则报错，否则生成语法树，`同时会验证客户端是否有相关权限`。生成语法树后，还会对语法进行优化。

   - **Optimizer**：主要作用是生成执行计划。执行计划中会表明是否使用索引，使用那些索引，表之间的连接顺序如何等等。它使用“`选取-投影-连接`”策略进行查询。例如：

     > SELECT id, name FROM student WHERE gender = '女';

     这个SELECT查询会先根据WHERE语句进行`选取`，而不是将全表查询出来以后再进行gender过滤。

     这个SELECT查询先根据id和name进行属性`投影` ，而不是将属性全部取出以后再进行过滤。

     最后将这两个查询条件`连接`起来生成最终查询结果。

   - **Cache & Buffer**：查询缓存，用于缓存已经执行过的查询语句及其查询结果，以key-value的形式进行存储。若以后有`完全相同`的查询语句（多一个空格都不行），则通过查询缓存直接返回结果。

     这个缓存可以在`不同客户端之间共享`。

     `在MySQL 8.0中被移除了`。

4. **引擎层**：负责MySQL中数据的存储和提取，对物理服务器级别维护的底层互数据执行操作。MySQL支持多种存储引擎，是插件式的存储引擎架构，开发人员可以根据实际需求选择合适的存储引擎。

   MySQL默认支持的存储引擎如下：

   <img src="MySQL高级篇.assets/image-20220920023117718.png" alt="image-20220920023117718" style="zoom:80%;" />

5. **存储层**：数据以文件的形式存放在物理磁盘中。

### 小结

MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：

<img src="MySQL高级篇.assets/image-20220920023437604.png" alt="image-20220920023437604" style="zoom:67%;" />

简化为三层结构：

1. 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；

2. SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；

3. 存储引擎层：与数据库文件打交道，负责数据的存储和读取。

## 1.2 SQL执行流程

<img src="MySQL高级篇.assets/image-20220920023627212.png" alt="image-20220920023627212" style="zoom: 80%;" />

SQL语句在MySQL中的执行流程是：`SQL语句 → 查询缓存(8.0之后移除) → 解析器 → 优化器 → 执行器(存储引擎)`。

<img src="MySQL高级篇.assets/image-20220920024358240.png" alt="image-20220920024358240" style="zoom:80%;" />



### 总结

- 查询缓存
- 解析器：词法分析，语法分析，语义分析 → 语法树
- 优化器：逻辑优化(重写SQL)，物理优化 → 执行计划
- 执行器：调用存储引擎API进行执行

## 1.3 SQL语法顺序

随着MySQL版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。

需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息，下面是经常出现的查询顺序：

<img src="MySQL高级篇.assets/image-20220920025123343.png" alt="image-20220920025123343" style="zoom:80%;" />

MySQL中的语法顺序为`from → on → join → where → group by → having → select → distinct → union → order by → limit`

## 1.4 数据库缓冲池

### 1.4.1 缓冲池的概念

`InnoDB存储引擎是以页为单位来管理存储空间的`，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘I/O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，`DBMS会申请占用内存来作为数据缓冲池` ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer Pool之后才可以访问。

这样做的好处是可以让`磁盘活动最小化`，从而`减少与磁盘直接进行I/O的时间` 。要知道，这种策略对提升SQL语句的查询性能来说`至关重要`。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。

在InnoDB存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示：

<img src="MySQL高级篇.assets/image-20220920025942315.png" alt="image-20220920025942315" style="zoom:67%;" />

从图中，你能看到InnoDB缓冲池包括了`数据页`、`索引页`、`插入缓冲`、`锁信息`、`自适应Hash`和`数据字典信息`等。

### 1.4.2 缓存池的重要性

对于使用InnoDB作为存储引擎的表来说，不管是用于存储用户数据的索引(包括聚簇索引和二级索引)，还是各种系统数据，都是以页的形式存放在表空间中的，而所谓的表空间只不过是InnoDB对文件系统上一个或几个实际文件的抽象，也就是说我们的数据说到底还是存储在磁盘上的。但是各位也都知道，磁盘的速度慢的跟乌龟一样，怎么能配得上“快如风，疾如电”的CPU呢?这里，缓冲池可以帮助我们衡除CPU和磁盘之间的鸿沟。所以InnoDB存储引擎在处理客户端的请求时，`当需要访问某个页的数据时，就会把完整的页的数据全部加载到内存中，也就是说即使我们只需要访问一个页的一条记录，那也需要先把整个页的数据加载到内存中`。将整个页加载到内存中后就可以进行读写访问了，在进行完读写访问之后并不着急把该页对应的内存空间释放掉，而是将其缓存起来，这样将来有请求再次访问该页面时，就可以省去磁盘IO的开销了。

### 1.4.3 缓存原则

`位置 * 频次`这个原则，可以帮我们对 I/O 访问效率进行优化。

首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。

其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有200G，但是内存只有16G，缓冲池大小只有1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会`优先对使用频次高的热数据进行加载`。

### 1.4.4 缓存池的预读特性

了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：预读。

缓冲池的作用就是提升I/O效率，而我们进行读取数据的时候存在一个“`局部性原理`”，也就是说`我们使用了一些数据，大概率还会使用它周围的一些数据`，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘I/O操作。

### 1.4.5 缓冲池读取数据的流程

缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。缓存在数据库中的结构和作用如下图所示：

<img src="MySQL高级篇.assets/image-20220920031317505.png" alt="image-20220920031317505" style="zoom: 80%;" />

如果我们执行SQL语句的时候更新了缓存池中的数据，那么`这些数据会马上同步到磁盘上吗?`

实际上，当我们对数据库中的记录进行修改的时候，`首先会修改缓冲池中页里面的记录信息`，然后数据库会`以一定的频率刷新到磁盘上`。注意并不是每次发生更新操作，都会立刻进行磁盘回写。缓冲池会采用一种叫做`checkpoint`的机制将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。

比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用`checkpoint`的方式，将不常用的脏页回写到磁盘上，然后再从缓冲池中将这些页释放掉。这里`脏页(dirty page)`指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。

### 1.4.6 缓冲池的常用命令

**查看缓冲池大小**

如果你使用的是InnoDB存储引擎，可以通过查看`innodb_buffer_pool_size`变量来查看缓冲池的大小。命令如下：

> show variables like 'innodb_buffer_pool_size';

<img src="MySQL高级篇.assets/image-20220920032019179.png" alt="image-20220920032019179" style="zoom:80%;" />

你能看到此时InnoDB的缓冲池大小只有 134217728/1024/1024 = 128MB。



**设置缓冲池大小**

我们可以修改缓冲池大小，比如改为256MB，方法如下：

> set global innodb_buffer_pool_size = 268435456;

或者再配置文件中进行配置：

> [server] 
>
> innodb_buffer_pool_size = 268435456



**创建多个缓冲池**

在配置文件中进行配置：

> [server] 
>
> innodb_buffer_pool_instances = 2



**查看缓冲池个数**

使用如下命令查看缓冲池个数

> show variables like 'innodb_buffer_pool_instances'; 

那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的：

> innodb_buffer_pool_size/innodb_buffer_pool_instances

也就是总共的大小除以实例的个数，结果就是每个Buffer Pool实例占用的大小。



# 第二章 存储引擎

## 2.1 存储引擎基本概念

为了管理方便，人们把**连接管理、查询缓存、语法解析、查询优化**这些并不涉及真实数据存储的功能划分为MySQL server的功能，把真实存取数据的功能划分为存储引擎的功能。所以在MySQL server完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

MySQL中提到了存储引擎的概念。简而言之，`存储引擎就是指表的类型`。其实存储引擎以前叫做`表处理器`，后来改名为存储引擎，`它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作`。

**查看MySQL提供什么存储引擎**

<img src="MySQL高级篇.assets/image-20220920034947994.png" alt="image-20220920034947994" style="zoom:80%;" />

## 2.2 InnoDB：具备外键支持功能的事务存储引擎

> 有外键功能并不一定是优势，阿里规约就规定，不可使用外键约束，因为外键约束不好维护，性能差。外键更多的是在Java代码层面进行逻辑处理。

- InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。

- 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。

- 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。

- 数据文件结构：

  - 表名：`.frm` ，存储表结构（MySQL8.0时，合并在表名.ibd中）

  - 表名：`.ibd` ，存储数据和索引

- `InnoDB是为处理巨大数据量的最大性能设计`。

- 对比MyISAM的存储引擎，`InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引`。

- InnoDB不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响；MyISAM只缓存索引，不缓存真实数据。

## 2.3  MyISAM：主要的非事务处理存储引擎

- MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。 

- 5.5之前默认的存储引擎

- 优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用

- 针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高

- 数据文件结构：

  - 表名：`.frm` ，存储表结构

  - 表名：`.MYD` ，存储数据 (MYData)

  - 表名：`.MYI` ，存储索引 (MYIndex)

- 应用场景：只读应用或者以读为主的业务

## 4.3 Archive：用于数据存档

- archive是归档的意思，仅仅支持插入和查询两种功能(行被插入后不能再修改）。
- 在MySQL 5.5以后支持索引功能。
- 拥有很好的压缩机制，使用`zlib压缩库`，在记录请求的时候实时的进行压缩，经常被用来作为仓库使用。
- 数据文件的扩展名为.ARZ。
- 同样数据量下，Archive表比MyISAM表要小大约`75%`，比支持事务处理的InnoDB表小大约`83%`。
- ARCHIVE存储引擎采用了`行级锁`。该ARCHIVE引擎支持 AUTO_INCREMENT列属性。AUTO_INCREMENT列可以具有唯一索引或非唯一索引。`尝试在任何其他列上创建索引会导致错误`。
- `Archive表适合日志和数据采集（档案）类应用`；适合存储大量的独立的作为历史记录的数据。`拥有很高的插入速度，但是对查询的支持较差`。

下表展示了ARCHIVE存储引擎功能

| **特征**                                                | **支持**     |
| ------------------------------------------------------- | ------------ |
| B树索引                                                 | 不支持       |
| `备份/时间点恢复`（在服务器中实现，而不是在存储引擎中） | 支持         |
| 集群数据库支持                                          | 不支持       |
| 聚集索引                                                | 不支持       |
| `压缩数据 `                                             | 支持         |
| 数据缓存                                                | 不支持       |
| 加密数据（加密功能在服务器中实现）                      | 支持         |
| 外键支持                                                | 不支持       |
| 全文检索索引                                            | 不支持       |
| 地理空间数据类型支持                                    | 支持         |
| 地理空间索引支持                                        | 不支持       |
| 哈希索引                                                | 不支持       |
| 索引缓存                                                | 不支持       |
| `锁粒度`                                                | 行锁         |
| MVCC                                                    | 不支持       |
| 存储限制                                                | 没有任何限制 |
| 交易                                                    | 不支持       |
| `更新数据字典的统计信息 `                               | 支持         |

## 4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容

- Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。

- 但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。

## 4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项

- `CSV引擎可以将普通的CSV文件作为MySQL的表来处理`，但不支持索引。
- CSV引擎可以作为一种数据交换的机制，非常有用。
- CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。
- 对于数据的快速导入、导出是有明显优势的。
- 数据文件扩展名为.CSV，元数据文件扩展名为.CSM

## 4.6 Memory：置于内存的表

Memory采用的逻辑介质是内存，响应速度很快，但是`当mysqld守护进程结束的时候，数据会丢失`。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。

- Memory同时支持`哈希（HASH）索引`和`B+树索引` 。 

- Memory表至少比MyISAM表要快一个数量级 。 

- MEMORY表的大小是受到限制的。表的大小主要取决于两个参数，分别是max_rows和max_heap_table_size。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默认为16MB，可以按需要进行扩大。

- 数据文件与索引文件分开存储。

- 缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。

使用Memory存储引擎的场景：

1. 目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出。可以通过参数max_heap_table_size控制Memory表的大小，限制Memory表的最大的大小。

2. 如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。
3. 存储在Memory表中的数据如果突然间丢失的话也没有太大的关系。

## 4.7 Federated：访问远程表

Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的 。 

## 4.8 Merge：管理多个MyISAM表构成的表集合

## 4.9 NDB：集群专用存储引擎

也叫做NDB Cluster存储引擎，主要用于MySQL Cluster分布式集群环境，类似 Oracle的RAC集群。

## 4.10 引擎对比 

| 特点         | MyISAM                 | InnoDB             | MEMORY | MERGE | NDB  |
| ------------ | ---------------------- | ------------------ | ------ | ----- | ---- |
| 存储限制     | 有                     | 64TB               | 有     | 没有  | 有   |
| 事务安全     |                        | 支持               |        |       |      |
| 锁机制       | 表锁                   | 行锁               | 表锁   | 表锁  | 行锁 |
| B树索引      | 支持                   | 支持               | 支持   | 支持  | 支持 |
| 哈希索引     |                        |                    | 支持   |       | 支持 |
| 全文索引     | 支持                   |                    |        |       |      |
| 集群索引     |                        | 支持               |        |       |      |
| 数据缓存     |                        | 支持               | 支持   |       | 支持 |
| 索引缓存     | 只缓存索引，不缓存数据 | 缓存索引和真实数据 | 支持   | 支持  | 支持 |
| 数据可压缩   | 支持                   |                    |        |       |      |
| 空间使用     | 低                     | 高                 | 不使用 | 低    | 低   |
| 内存使用     | 低                     | 高                 | 中等   | 高    | 高   |
| 批量插入速度 | 高                     | 低                 | 高     | 高    | 高   |
| 支持外键     |                        | 支持               |        |       |      |

其实我们最常用的就是InnoDB和MyISAM，有时会提一下Memory。其中InnoDB是MySQL默认的存储引擎。



## 4.11 课外补充：详解InnoDB

### 4.11.1 InnoDB表的优势

- InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。

- InnoDB崩溃恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。

- InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。

- InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高查询的速度。
- 使用InnoDB可以压缩表和相关的索引，可以在不影响性能和可用性的情况下创建或删除索引。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。
- 在同一个语句中，InnoDB表可以与其他存储引擎表混用。
- 即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。当处理大数据量时，InnoDB兼顾CPU，以达到最大性能。

### 4.11.2 InnoDB与ACID模型

ACID模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应用非常重要。

下面讲解InnoDB存储引擎与ACID模型相同作用的四个方面：

1. **原子性**：ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括：

- 自动提交设置。

- COMMIT语句。

- ROLLBACK语句。

操作INFORMATION_SCHEMA库中的表数据。

2. **一致性**：ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性

- 主要包括：

- InnoDB双写缓存。

- InnoDB崩溃恢复。

3. **隔离性**：隔离是应用于事务的级别，与MySQL相关的特性主要包括：

- 自动提交设置。

- SET ISOLATION LEVEL语句。

- InnoDB锁的低级别信息。

4. **持久性**：ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循。

### 4.11.3 InnoDB**架构** 

1. **缓冲池**：缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。

2. **更改缓存**：更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。在磁盘中，更新缓存是系统表空间的一部分。

3. **自适应哈希索引**：自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行，不需要降低事务上的性能或可靠性。

4. **重做日志缓存**：重做日志缓存存放要放入重做日志的数据。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。

5. **系统表空间**：系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。

6. **双写缓存**：双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB才会将数据页写入合适的位置。

7. **撤销日志**：撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。

8. **每个表一个文件的表空间**：每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。每个表空间由一个单独的.ibd数据文件代表，该文件默认被创建在数据库目录中。

9. **通用表空间**：使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数据目录之外能够管理多个表并支持所有行格式的表。

10. **撤销表空间**：撤销表空间由一个或多个包含撤销日志的文件组成。

11. **临时表空间**：用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。

12. **重做日志**：重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。
